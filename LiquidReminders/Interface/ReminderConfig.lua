local _, LRP = ...

local buttonSize = 24
local spacing = 8
local iconSize = 24
local editBoxHeight = 24
local currentGlowType -- The glow type that is currently being previewed

local timelineData -- The timeline data for the encounter that the 

-- Unique identifier that this reminder is indexed by in SavedVariables (as generated by LRP:GenerateUniqueID)
-- Along with the encounterID (timelineData.id) this is used to uniquely identify a reminder
local reminderID 

local reminderData = {
    load = {
        type = "ALL", -- Who this reminder should show for ("ALL", "NAME", "POSITION", "CLASS_SPEC", or "ROLE")
        -- name = "",
        -- class = "",
        -- spec = "",
        -- role = ""
        -- position = ""
    },
    trigger = {
        -- relativeTo = {
        --     event = "SPELL_CAST_SUCCESS", -- CLEU event that the reminder is relative to
        --     spellID = 123456, -- spellID relating to above CLEU event
        --     count = 1 -- Count of above CLEU/spellID combination that the reminder is relative to
        -- },
        time = 0, -- Time relative to pull (or event) when the reminder should finish showing
        duration = 8, -- Number of seconds the reminder shows for
        hideOnUse = true -- Hides the spell reminder when you cast the spell
    },
    display = {
        type = "TEXT", -- "TEXT" or "SPELL"
        -- spellID = 0, -- Spell ID that should show (in case of SPELL reminder)
        text = "", -- Reminder text (in case of TEXT reminder)
        color = {
            r = 1,
            g = 1,
            b = 1
        }
    },
    tts = { -- Whether text-to-speech should play for this reminder
        enabled = false,
        time = 0, -- Time duration on the reminder when the TTS should play.
        voice = 0
    },
    glow = {
        enabled = false,
        names = {}, -- Player name(s) to glow while the reminder is showing
        type = "PIXEL", -- "PIXEL", "AUTOCAST", "BUTTON", or "PROC"
        color = {
            r = 0.95,
            g = 0.95,
            b = 0.32
        }
    }
}

local defaultReminder = CopyTable(reminderData) -- Used to reset config back to default

local windowWidth = 470
local windowHeight = 400

local screenWidth, screenHeight = GetPhysicalScreenSize()

-- Constants for use in dropdowns
local spellDropdownShouldUpdate = true
local playerClass, playerClassFile, playerClassID = UnitClass("player")
local classSortOrder = tInvert(CLASS_SORT_ORDER) -- Used for ordering dropdowns
local coloredClasses = {}
local classIcons = {}

for classID = 1, GetNumClasses() do
    local className, classFile = GetClassInfo(classID)
    local colorStr = RAID_CLASS_COLORS[classFile].colorStr

    coloredClasses[classFile] = string.format("|c%s%s|r", colorStr, className)
    classIcons[classFile] = string.format("interface\\icons\\classicon_%s.blp", classFile:lower())
end

-- Widgets
local reminderTypeDropdownInfoTable
local targetNameEditBox, targetDropdown, relativeToDropdown, timeEditBox, durationSlider, reminderColorPicker, textReminderEditBox, spellReminderEditBoxIcon, spellReminderEditBox, hideOnUseCheckButton, reminderTypeDropdown, ttsTimeSlider, ttsCheckButton, glowNamesEditBox, glowCheckButton, acceptButton, deleteButton, relativeToSpellEditBox, relativeToCountEditBox, relativeToSpellIcon, glowTypeDropdown, glowColorPicker, makeDefaultButton, testButton, glowPreviewFrame

-- For the currently set timelineData, find the phase that a reminder is relative to
-- This is used when loading in a reminder to know which phase to select from the dropdown
local function GetPhaseFromReminder(_reminderData)
    local relativeTo = _reminderData.trigger.relativeTo
    
    if not relativeTo then
        return 0 -- Relative to pull
    end

    local event = relativeTo.event
    local spellID = relativeTo.spellID
    local count = relativeTo.count

    for phaseCount, phaseInfo in ipairs(timelineData.phases) do
        if phaseInfo.event == event and phaseInfo.spellID == spellID and phaseInfo.count == count then
            return phaseCount
        end
    end

    -- If we are here, no phase was matched, even though the reminder is relative to an event (not to pull)
end

-- Creates (or updates) a reminder from the selected settings
local function CreateReminder()
    local encounterID = timelineData.id

	if not LiquidRemindersSaved.reminders[encounterID] then
		LiquidRemindersSaved.reminders[encounterID] = {}
	end

    LiquidRemindersSaved.reminders[encounterID][reminderID] = CopyTable(reminderData)

	LRP:BuildReminderLines()
end

-- Sets the config to match an existing reminder
-- If no reminder matching this encounterID/reminderID combination exists, loads in default settings
function LRP:LoadReminder(_timelineData, _reminderID)
    timelineData = _timelineData
    reminderID = _reminderID

    local encounterID = timelineData.id
	local newReminder = LiquidRemindersSaved.reminders[encounterID] and LiquidRemindersSaved.reminders[encounterID][_reminderID]

	if not newReminder then
        if LiquidRemindersSaved.settings.defaultReminder then
            newReminder = CopyTable(LiquidRemindersSaved.settings.defaultReminder)
        else
		    newReminder = CopyTable(defaultReminder)
        end

        -- By default new reminders are set to target the player's current class
        local class = UnitClassBase("player")

        newReminder.load.type = "CLASS_SPEC"
        newReminder.load.class = class
        newReminder.load.spec = class -- We set spec equal to class to indicate that it's class-wide
	end

    -- Populate the phase dropdown
	local infoTable = {
		[1] = {text = "Pull", value = 0}
	}

	for phaseCount, phaseInfo in ipairs(timelineData.phases) do
		table.insert(
			infoTable,
			{
				text = phaseInfo.name,
				value = phaseCount
			}
		)
	end

    table.insert(
        infoTable,
        {
            text = "Event",
            value = "EVENT",
            children = {
                [1] = {
                    text = "SPELL_CAST_START",
                    value = "SPELL_CAST_START"
                },
                [2] = {
                    text = "SPELL_CAST_SUCCESS",
                    value = "SPELL_CAST_SUCCESS"
                },
                [3] = {
                    text = "SPELL_AURA_APPLIED",
                    value = "SPELL_AURA_APPLIED"
                },
                [4] = {
                    text = "SPELL_AURA_REMOVED",
                    value = "SPELL_AURA_REMOVED"
                },
                [5] = {
                    text = "UNIT_SPELLCAST_START",
                    value = "UNIT_SPELLCAST_START"
                },
                [6] = {
                    text = "UNIT_SPELLCAST_SUCCEEDED",
                    value = "UNIT_SPELLCAST_SUCCEEDED"
                },
                [7] = {
                    text = "UNIT_DIED",
                    value = "UNIT_DIED"
                }
            }
        }
    )

	relativeToDropdown:SetInfoTable(infoTable)

    -- Load
    local targetType = newReminder.load.type

    if targetType == "ALL" then
        targetDropdown:SetValue({1})
    elseif targetType == "NAME" then
        targetDropdown:SetValue({2})
    elseif targetType == "CLASS_SPEC" then
        local class = newReminder.load.class
        local spec = newReminder.load.spec

        targetDropdown:SetValue({3, classSortOrder[class], spec == class and 1 or spec + 1})
    elseif targetType == "ROLE" then
        local role = newReminder.load.role

        targetDropdown:SetValue({4, role == "TANK" and 1 or role == "HEALER" and 2 or 3})
    elseif targetType == "POSITION" then
        local position = newReminder.load.position

        targetDropdown:SetValue({5, position == "MELEE" and 1 or 2})
    end

    targetNameEditBox:SetText(newReminder.load.name or "")

    -- Trigger
    local phaseFromTrigger = GetPhaseFromReminder(newReminder)

    if phaseFromTrigger then
        relativeToDropdown:SetValue({phaseFromTrigger + 1})
    else
        local eventIndices = {
            SPELL_CAST_START = 1,
            SPELL_CAST_SUCCESS = 2,
            SPELL_AURA_APPLIED = 3,
            SPELL_AURA_REMOVED = 4,
            UNIT_SPELLCAST_START = 5,
            UNIT_SPELLCAST_SUCCEEDED = 6,
            UNIT_DIED = 7
        }

        relativeToDropdown:SetValue({#infoTable, eventIndices[newReminder.trigger.relativeTo.event]})
        relativeToSpellEditBox:SetText(newReminder.trigger.relativeTo.spellID or "")
        relativeToCountEditBox:SetText(newReminder.trigger.relativeTo.count or "")
    end
    
    timeEditBox:SetText(newReminder.trigger.time or "")
    durationSlider:SetValue(newReminder.trigger.duration)
    hideOnUseCheckButton:SetChecked(newReminder.trigger.hideOnUse)

    -- Display
    local reminderType = newReminder.display.type

    if reminderType == "TEXT" then
        reminderTypeDropdown:SetValue({1})
        spellReminderEditBox:SetText(0)
    else -- SPELL reminder
		reminderTypeDropdown:SetValue({3})
		spellReminderEditBox:SetText(newReminder.display.spellID or 0)
    end

    textReminderEditBox:SetText(newReminder.display.text or "")

    local color = newReminder.display.color
    reminderColorPicker:SetColor(color.r, color.g, color.b, 1)

    -- TTS
    ttsCheckButton:SetChecked(newReminder.tts.enabled)
    ttsTimeSlider:SetValue(newReminder.tts.time)
    
    -- Glow
    local glowNames = ""
    local glowColor = newReminder.glow.color
    local glowTypeToIndex = {
        PIXEL = 1,
        AUTOCAST = 2,
        BUTTON = 3,
        PROC = 4
    }

    glowCheckButton:SetChecked(newReminder.glow.enabled)

    for _, glowName in ipairs(newReminder.glow.names) do
        glowNames = string.format(glowNames == "" and "%s%s" or "%s, %s", glowNames, glowName)
    end

    glowNamesEditBox:SetText(glowNames)
    glowTypeDropdown:SetValue({glowTypeToIndex[newReminder.glow.type]})
    glowColorPicker:SetColor(glowColor.r, glowColor.g, glowColor.b, 1)
end

-- Sets the encounterID/phase/time based on where the user clicked the timeline
function LRP:CreateReminderFromTimeline(_timelineData, phase, combatTime)
	LRP:LoadReminder(_timelineData, LRP:GenerateUniqueID()) -- Reset config to default settings

    -- Set phase
	relativeToDropdown:SetValue({phase + 1})

	-- Set combat time
	timeEditBox:SetText(combatTime)

	CreateReminder()
	LRP.reminderConfig:Show()
end

-- Updates the spell portion of the reminder type dropdown (should be called whenever a new spellID is detected)
local function UpdateSpellDropdown(initialUpdate)
    if not spellDropdownShouldUpdate then return end

    -- Initially update all class tables, subsequent updates only do our own
    for classFile, specTables in pairs(initialUpdate and LiquidRemindersSaved.spellBookData or {[playerClassFile] = LiquidRemindersSaved.spellBookData[playerClassFile]}) do
        local classIndex = classSortOrder[classFile]

        for specID = 0, #specTables do -- 0 are class-wide spells
            local specTable = specTables[specID]

            reminderTypeDropdownInfoTable[2].children[classIndex].children[specID + 1].children = {}
            local targetTable = reminderTypeDropdownInfoTable[2].children[classIndex].children[specID + 1].children

            for spellID in pairs(specTable) do
                local spellInfo = C_Spell.GetSpellInfo(spellID)

                table.insert(
                    targetTable,
                    {
                        text = spellInfo.name,
                        value = spellID,
                        icon = spellInfo.iconID
                    }
                )
            end

            table.sort(
                targetTable,
                function(spellA, spellB)
                    return spellA.text < spellB.text
                end
            )
        end
    end

    spellDropdownShouldUpdate = false
end

-- Iterates through the player's spellbook spells, and adds them to the SavedVariables table
-- These are then used to populate the spell dropdown
-- Whenever a new spell is found, spellDropdownShouldUpdate is set to true
local function CollectSpellBookData()
    if not LiquidRemindersSaved.spellBookData[playerClassFile] then
        LiquidRemindersSaved.spellBookData[playerClassFile] = {[0] = {}} -- Table 0 are class-wide spells
    end

    local dropdownIndices = {
        [playerClass] = 0
    }

    for specIndex = 1, GetNumSpecializationsForClassID(playerClassID) do
        local _, specName = GetSpecializationInfoForClassID(playerClassID, specIndex)

        if not LiquidRemindersSaved.spellBookData[playerClassFile][specIndex] then
            LiquidRemindersSaved.spellBookData[playerClassFile][specIndex] = {}
        end

        dropdownIndices[specName] = specIndex
    end

    for tabIndex = 1, C_SpellBook.GetNumSpellBookSkillLines() do
        local skillLineInfo = C_SpellBook.GetSpellBookSkillLineInfo(tabIndex)

        local tabName = skillLineInfo.name
        local offset = skillLineInfo.itemIndexOffset
        local numSlots = skillLineInfo.numSpellBookItems
        local dropdownIndex = dropdownIndices[tabName]

        if dropdownIndex then -- Only index class/spec spells
            for spellIndex = offset + 1, offset + numSlots do
                local spellInfo = C_SpellBook.GetSpellBookItemInfo(spellIndex, Enum.SpellBookSpellBank.Player)
                local spellID = spellInfo.spellID
                local isPassive = spellInfo.isPassive

                if spellID and not isPassive then
                    if not LiquidRemindersSaved.spellBookData[spellID] then
                        spellDropdownShouldUpdate = true
                    end
    
                    LiquidRemindersSaved.spellBookData[playerClassFile][dropdownIndex][spellID] = spellInfo.name:lower()
                end
            end
        end
    end
end

-- When talents are changed, lots of LEARNED_SPELL_IN_SKILL_LINE events happen
-- We only want to update the spellbook once, not on every event
local spellBookUpdateQueued

local function QueueSpellBookUpdate(initialUpdate)
    if not spellBookUpdateQueued then
        C_Timer.NewTimer(
            1,
            function()
                CollectSpellBookData()
                UpdateSpellDropdown(initialUpdate)

                spellBookUpdateQueued = false
            end
        )

        spellBookUpdateQueued = true
    end
end

local function UpdatePreviewGlow()
    -- Remove previous glow
    if currentGlowType then
        LRP:StopGlow(glowPreviewFrame, "preview_glow", currentGlowType)

        currentGlowType = nil
    end

    -- Add new glow (if any)
    if reminderData.glow.enabled then
        LRP:StartGlow(glowPreviewFrame, "preview_glow", reminderData.glow.type, reminderData.glow.color)

        currentGlowType = reminderData.glow.type
    end
end

function LRP:InitializeConfig()
    LRP.reminderConfig = LRP:CreateWindow("Config", true, true, false)

    -- If this is the first time this addon loads (and there's no position data for the config yet)
    if not LiquidRemindersSaved.settings.frames["Config"] then
        LRP.reminderConfig:SetPoint("TOPLEFT", UIParent, "TOPLEFT", (screenWidth - windowWidth) / 2, -(screenHeight - windowHeight) / 2)
    end

    LRP.reminderConfig:SetSize(windowWidth, windowHeight)
    LRP.reminderConfig:SetFrameStrata("HIGH")
    
    LRP:AddTooltip(LRP.reminderConfig.buttons[1], "Close without saving") -- First button is the exit button

    -- Duration slider
    durationSlider = LRP:CreateSlider(
        LRP.reminderConfig,
        "Duration",
        1,
        30,
        function(duration)
            reminderData.trigger.duration = duration
        end
    )
    
    LRP:AddTooltip(durationSlider, "Time (in seconds) that the reminder should show for.")
    
    -- Target dropdown/target name edit box
    targetNameEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Character name",
        function(name)
            reminderData.load.name = name

            if name == "" then
                targetNameEditBox:ShowHighlight(1, 0, 0)

                targetNameEditBox.secondaryTooltipText = "|cffff0000Character name must be provided for this reminder to show."
                LRP:RefreshTooltip()
            else
                targetNameEditBox:HideHighlight()

                targetNameEditBox.secondaryTooltipText = nil
                LRP:RefreshTooltip()
            end
        end
    )
    
    local targetDropdownInfoTable = {
        [1] = {
            text = "All",
            value = "ALL"
        },
        [2] = {
            text = "Name",
            value = "NAME"
        },
        [3] = {
            text = "Class/spec",
            value = "CLASS_SPEC",
            children = {
            }
        },
        [4] = {
            text = "Role",
            value = "ROLE",
            children = {
                [1] = {
                    text = "Tank",
                    value = "TANK",
                    icon = "groupfinder-icon-role-large-tank"
                },
                [2] = {
                    text = "Healer",
                    value = "HEALER",
                    icon = "groupfinder-icon-role-large-heal"
                },
                [3] = {
                    text = "DPS",
                    value = "DAMAGER",
                    icon = "groupfinder-icon-role-large-dps"
                }
            }
        },
        [5] = {
            text = "Position",
            value = "POSITION",
            children = {
                [1] = {
                    text = "Melee",
                    value = "MELEE",
                    icon = classIcons["WARRIOR"]
                },
                [2] = {
                    text = "Ranged",
                    value = "RANGED",
                    icon = classIcons["HUNTER"]
                }
            }
        }
    }
    
    for classID = 1, GetNumClasses() do
        local _, classFile = GetClassInfo(classID)
        local colorStr = RAID_CLASS_COLORS[classFile].colorStr
        local coloredClass = coloredClasses[classFile]
        local classIcon = classIcons[classFile]
    
        local entry = {
            text = coloredClass,
            value = classFile,
            icon = classIcon,
            children = {
                [1] = {
                    text = coloredClass,
                    value = classFile,
                    icon = classIcon
                }
            }
        }
    
        for specIndex = 1, GetNumSpecializationsForClassID(classID) do
            local _, specName, _, specIcon = GetSpecializationInfoForClassID(classID, specIndex)
    
            if specName then
                table.insert(
                    entry.children,
                    {
                        text = string.format("|c%s%s|r", colorStr, specName),
                        value = specIndex,
                        icon = specIcon
                    }
                )
            end
        end
    
        local sortOrder = classSortOrder[classFile]
    
        if sortOrder then
            targetDropdownInfoTable[3].children[sortOrder] = entry
        end
    end
    
    targetDropdown = LRP:CreateDropdown(
        LRP.reminderConfig,
        "Target",
        targetDropdownInfoTable,
        function(targetType, ...)
            reminderData.load.type = targetType
    
            if targetType == "ROLE" then
                reminderData.load.role = ...
            elseif targetType == "POSITION" then
                local position = ...

                reminderData.load.position = position
            elseif targetType == "CLASS_SPEC" then
                local class, specIndex = ...
    
                reminderData.load.class = class
                reminderData.load.spec = specIndex
            end
            
            -- Position widgets
            if targetType == "NAME" then
                targetNameEditBox:Show()

                durationSlider:SetPoint("LEFT", targetNameEditBox, "RIGHT", spacing, 0)
            else
                targetNameEditBox:Hide()

                durationSlider:SetPoint("LEFT", targetDropdown, "RIGHT", spacing, 0)
            end
        end
    )
    
    targetDropdown:SetPoint("TOPLEFT", LRP.reminderConfig, "TOPLEFT", spacing, -44)
    UIDropDownMenu_SetWidth(targetDropdown, 120)
    LRP:AddTooltip(targetDropdown, "The character/class/spec/role that this reminder should show for.")
    
    -- Target name edit box
    targetNameEditBox:SetPoint("LEFT", targetDropdown, "RIGHT", spacing, 0)
    targetNameEditBox:SetSize(120, editBoxHeight)
    targetNameEditBox:SetShown(reminderData.targetType == "NAME")

    LRP:AddTooltip(targetNameEditBox, "Character that this reminder should show for. Does |cffff0000not|r support multiple entries.")
    
    -- Relative to spell ID edit box (SetPoint happens after relativeToDropdown initialization)
    relativeToSpellEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Spell ID/npc ID",
        function(spellID)
            spellID = tonumber(spellID)

            if not spellID then
                relativeToSpellEditBox:SetText(0)

                return
            end

            if reminderData.trigger.relativeTo then
                reminderData.trigger.relativeTo.spellID = spellID
            end

            if relativeToSpellIcon then
                relativeToSpellIcon:SetSpellID(spellID)
            end

            local spellInfo = C_Spell.GetSpellInfo(spellID) -- Check if this is a valid spell ID
            local event = reminderData.trigger.relativeTo and reminderData.trigger.relativeTo.event

            if spellInfo and event then
                -- Check if this event/spellID combination is present in timeline data
                for _, eventInfo in ipairs(timelineData.events) do
                    if event == eventInfo.event and spellID == eventInfo.spellID then
                        relativeToSpellEditBox:HideHighlight()

                        relativeToSpellEditBox.secondaryTooltipText = nil
                        LRP:RefreshTooltip()

                        relativeToCountEditBox:Refresh() -- Count edit box highlight depends on this spell ID, refresh it

                        return
                    end
                end

                relativeToSpellEditBox:ShowHighlight(1, 1, 0)

                relativeToSpellEditBox.secondaryTooltipText = "|cffffff00This event/spellID combination is not included in the timeline data. As such, this reminder cannot be displayed on the timeline.|n|nThe reminder may still appear during the encounter if this event occurs!|r"
                LRP:RefreshTooltip()
            else
                relativeToSpellEditBox:ShowHighlight(1, 0, 0)

                relativeToSpellEditBox.secondaryTooltipText = "|cffff0000Valid spell ID must be provided for this reminder to show."
                LRP:RefreshTooltip()
            end

            relativeToCountEditBox:Refresh() -- Count edit box highlight depends on this spell ID, refresh it
        end
    )

    relativeToSpellEditBox:SetSize(90, editBoxHeight)
    relativeToSpellEditBox:SetNumeric(true)

    LRP:AddTooltip(relativeToSpellEditBox, "Spell ID of the event that this reminder is relative to.")

    -- Relative to count edit box
    relativeToCountEditBox = LRP:CreateEditBox(
        relativeToSpellEditBox,
        "Count",
        function(count)
            count = tonumber(count)

            if not count then
                relativeToCountEditBox:SetText(1)

                return
            end

            if reminderData.trigger.relativeTo then
                reminderData.trigger.relativeTo.count = count
            end

            local event = reminderData.trigger.relativeTo and reminderData.trigger.relativeTo.event
            local spellID = reminderData.trigger.relativeTo and reminderData.trigger.relativeTo.spellID
            local spellInfo = spellID and C_Spell.GetSpellInfo(spellID)

            -- If the spell ID is invalid, the spell ID edit box will already be highlighted
            -- In this case, don't also highlight the count edit box
            if not spellInfo then
                relativeToCountEditBox:HideHighlight()

                relativeToCountEditBox.secondaryTooltipText = nil
                LRP:RefreshTooltip()

                return
            end

            if event and spellID then
                local spellIDFound = false -- Whether the event/spellID combination is valid
                local countFound = false -- Whether the count is valid (in case the event is valid)
                local entryCount = 0

                for _, eventInfo in ipairs(timelineData.events) do
                    if event == eventInfo.event and spellID == eventInfo.spellID then
                        spellIDFound = true

                        if eventInfo.entries[count] then
                            countFound = true
                        end

                        entryCount = #eventInfo.entries
                       
                        break
                    end
                end

                -- If the event/spell ID combination is not found, the spell ID edit box will already be highlighted
                -- In this case, don't also highlight the count edit box
                if spellIDFound then
                    if countFound then
                        relativeToCountEditBox:HideHighlight()

                        relativeToCountEditBox.secondaryTooltipText = nil
                        LRP:RefreshTooltip()

                        return
                    else
                        relativeToCountEditBox:ShowHighlight(1, 1, 0)

                        relativeToCountEditBox.secondaryTooltipText = string.format("|cffffff00There are only %d occurences of this event/spellID combination on the timeline. As such, this reminder cannot be displayed on the timeline.|n|nThe reminder may still appear during the encounter if this number of events occur!|r", entryCount)
                        LRP:RefreshTooltip()

                        return
                    end
                end
            end
            
            relativeToCountEditBox:HideHighlight()

            relativeToCountEditBox.secondaryTooltipText = nil
            LRP:RefreshTooltip()
        end
    )

    relativeToCountEditBox:SetSize(50, editBoxHeight)
    relativeToCountEditBox:SetPoint("LEFT", relativeToSpellEditBox, "RIGHT", spacing, 0)
    relativeToCountEditBox:SetNumeric(true)

    LRP:AddTooltip(relativeToCountEditBox, "The count of the event/spell ID combination that this reminder is relative to.")

    -- Relative to spell icon
    relativeToSpellIcon = LRP:CreateSpellIcon(relativeToCountEditBox)

    relativeToSpellIcon:SetParent(relativeToCountEditBox)
    relativeToSpellIcon:SetSize(iconSize, iconSize)
    relativeToSpellIcon:SetPoint("LEFT", relativeToCountEditBox, "RIGHT", spacing, 0)

    -- Time edit box
    timeEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Time",
        function(newTime)
            newTime = tonumber(newTime)

            if newTime then
                reminderData.trigger.time = newTime

                if newTime == 0 then
                    timeEditBox:ShowHighlight(1, 0, 0)

                    timeEditBox.secondaryTooltipText = "|cffff0000Reminders scheduled 0 seconds after pull (or after an event) will never show up.|r"
                    LRP:RefreshTooltip()
                else
                    timeEditBox:HideHighlight()

                    timeEditBox.secondaryTooltipText = nil
                    LRP:RefreshTooltip()
                end
            else
                timeEditBox:SetText(0)
            end
        end
    )
    
    timeEditBox:SetHeight(editBoxHeight)
    timeEditBox:SetNumericFullRange(true)
    timeEditBox:SetMinimum(1)
    
    LRP:AddTooltip(timeEditBox, "Time (in seconds) after the selected phase that the reminder should |cff29ff62finish|r showing.")

    -- Relative to dropdown
    relativeToDropdown = LRP:CreateDropdown(
        LRP.reminderConfig,
        "Relative to",
        {
            [1] = {text = "Pull", value = 0},
            [2] = {text = "Phase 1", value = 1},
            [3] = {text = "Intermission 1", value = 2},
            [4] = {text = "Phase 2", value = 3},
            [5] = {text = "Intermission 2", value = 4},
            [6] = {text = "Phase 3", value = 5},
            [7] = {
                text = "Event",
                value = "EVENT",
                children = {
                    [1] = {
                        text = "SPELL_CAST_START",
                        value = "SPELL_CAST_START"
                    },
                    [2] = {
                        text = "SPELL_CAST_SUCCESS",
                        value = "SPELL_CAST_SUCCESS"
                    },
                    [3] = {
                        text = "SPELL_AURA_APPLIED",
                        value = "SPELL_AURA_APPLIED"
                    },
                    [4] = {
                        text = "SPELL_AURA_REMOVED",
                        value = "SPELL_AURA_REMOVED"
                    },
                    [5] = {
                        text = "UNIT_SPELLCAST_START",
                        value = "UNIT_SPELLCAST_START"
                    },
                    [6] = {
                        text = "UNIT_SPELLCAST_SUCCEEDED",
                        value = "UNIT_SPELLCAST_SUCCEEDED"
                    },
                    [7] = {
                        text = "UNIT_DIED",
                        value = "UNIT_DIED"
                    }
                }
            }
        }, -- This is just dummy data to illustrate what the structure is. In reality it's always loaded from timeline data.
        function(arg1, arg2)
            if arg1 == "EVENT" then -- Relative to an event that is not a phase transition, or to an unknown event (i.e. not in timeline data)
                if not reminderData.trigger.relativeTo then
                    reminderData.trigger.relativeTo = {}
                end

                reminderData.trigger.relativeTo.event = arg2
                relativeToSpellEditBox:SetText(reminderData.trigger.relativeTo.spellID or "")
                relativeToCountEditBox:SetText(reminderData.trigger.relativeTo.count or "")

                -- Position widgets
                relativeToSpellEditBox:Show()

                timeEditBox:SetPoint("LEFT", relativeToSpellIcon, "RIGHT", spacing, 0)
                timeEditBox:SetPoint("RIGHT", LRP.reminderConfig, "RIGHT", -spacing, 0)

                relativeToSpellEditBox:Refresh() -- Spell ID edit box highlight depends on this event, refresh it
            else -- Relative to a known phase event (or pull)
                if arg1 == 0 then -- Relative to pull
                    reminderData.trigger.relativeTo = nil
                else
                    local phaseInfo = timelineData.phases[arg1]
    
                    reminderData.trigger.relativeTo = {
                        event = phaseInfo.event,
                        spellID = phaseInfo.spellID,
                        count = phaseInfo.count
                    }
                end

                -- Position widgets
                relativeToSpellEditBox:Hide()

                timeEditBox:ClearAllPoints()
                timeEditBox:SetWidth(80)
                timeEditBox:SetPoint("LEFT", relativeToDropdown, "RIGHT", spacing, 0)
            end
        end
    )
    
    relativeToDropdown:SetPoint("TOPLEFT", targetDropdown, "BOTTOMLEFT", 0, -30)
    UIDropDownMenu_SetWidth(relativeToDropdown, 120)
    LRP:AddTooltip(
        relativeToDropdown,
        "The phase that the reminder time is relative to." ..
        "|n|ne.g. if phase 2 starts at 1:00, and the time is set to 20, the reminder will finish showing at 1:20." ..
        "|n|n|cff29ff62This is auto-filled when creating a reminder on the timeline, so you should not have to touch this.|r"
    )

    relativeToSpellEditBox:SetPoint("LEFT", relativeToDropdown, "RIGHT", spacing, 0)

    -- Reminder color picker
    reminderColorPicker = LRP:CreateColorPicker(
        LRP.reminderConfig,
        "Color",
        function(r, g, b)
            reminderData.display.color = {
                r = r,
                g = g,
                b = b
            }
        end,
        false
    )

    reminderColorPicker:SetSize(20, 20)

    LRP:AddTooltip(reminderColorPicker, "Color that the reminder will show up in.")
    
    -- Reminder type
    textReminderEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Text",
        function(text)
            reminderData.display.text = strtrim(text)

            if text == "" then
                textReminderEditBox:ShowHighlight(1, 0, 0)

                textReminderEditBox.secondaryTooltipText = "|cffff0000Text must be provided for this reminder to show.|r"
                LRP:RefreshTooltip()
            else
                textReminderEditBox:HideHighlight()

                textReminderEditBox.secondaryTooltipText = nil
                LRP:RefreshTooltip()
            end
        end
    )
    
    spellReminderEditBoxIcon = LRP:CreateSpellIcon()
    
    spellReminderEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Spell ID",
        function(spellID)
            if type(spellID) == "string" and spellID ~= "" then -- Spell name input
                spellID = spellID:lower()

                local spellBookData = LiquidRemindersSaved.spellBookData[UnitClassBase("player")]

                if spellBookData then
                    for _, specSpellTable in pairs(spellBookData) do
                        for _spellID, spellName in pairs(specSpellTable) do
                            if spellID == spellName then
                                spellReminderEditBox:SetText(_spellID)

                                return
                            end
                        end
                    end
                end
            end

            spellID = tonumber(spellID)

            if spellID then
                local spellInfo = C_Spell.GetSpellInfo(spellID)

                reminderData.display.spellID = spellID
                spellReminderEditBoxIcon:SetSpellID(spellID)

                -- Check if a valid spell ID was provided
                if spellInfo then
                    spellReminderEditBox:HideHighlight()

                    spellReminderEditBox.secondaryTooltipText = nil
                    LRP:RefreshTooltip()
                else
                    spellReminderEditBox:ShowHighlight(1, 0, 0)

                    spellReminderEditBox.secondaryTooltipText = "|cffff0000Valid spell ID must be provided for this reminder to show.|r"
                    LRP:RefreshTooltip()
                end
            else
                spellReminderEditBox:SetText(0)
            end
        end
    )
    
    hideOnUseCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "Hide on use",
        function(hideOnUse)
            reminderData.trigger.hideOnUse = hideOnUse
        end
    )
    
    reminderTypeDropdownInfoTable = {
        [1] = {
            text = "Text",
            value = "TEXT"
        },
        [2] = {
            text = "Spell",
            value = "SPELL",
            children = {}
        },
        [3] = {
            text = "Spell ID",
            value = "SPELLID"
        }
    }
    
    for classID = 1, GetNumClasses() do
        local className, classFile = GetClassInfo(classID)
        local colorStr = RAID_CLASS_COLORS[classFile].colorStr
        local coloredClass = string.format("|c%s%s|r", colorStr, className)
        local classIcon = string.format("interface\\icons\\classicon_%s.blp", classFile:lower())
    
        local entry = {
            text = coloredClass,
            value = classFile,
            icon = classIcon,
            children = {
                [1] = {
                    text = coloredClass,
                    value = classFile,
                    icon = classIcon,
                    children = {
                        [1] = {
                            text = "No data",
                            value = "NODATA"
                        }
                    }
                }
            }
        }
    
        for specIndex = 1, GetNumSpecializationsForClassID(classID) do
            local _, specName, _, specIcon = GetSpecializationInfoForClassID(classID, specIndex)
    
            if specName then
                table.insert(
                    entry.children,
                    {
                        text = string.format("|c%s%s|r", colorStr, specName),
                        value = specIndex,
                        icon = specIcon,
                        children = {
                            [1] = {
                                text = "No data",
                                value = "NODATA"
                            }
                        }
                    }
                )
            end
        end
    
        reminderTypeDropdownInfoTable[2].children[classSortOrder[classFile]] = entry
    end
    
    reminderTypeDropdown = LRP:CreateDropdown(
        LRP.reminderConfig,
        "Type",
        reminderTypeDropdownInfoTable,
        function(reminderType, _, _, spellID)
            if reminderType == "TEXT" then
                reminderData.display.type = "TEXT"
    
                textReminderEditBox:Show()
                spellReminderEditBox:Hide()
                hideOnUseCheckButton:Hide()

                reminderColorPicker:SetPoint("LEFT", textReminderEditBox, "RIGHT", spacing, 0)
            elseif reminderType == "SPELLID" then
                reminderData.display.type = "SPELL"
    
                textReminderEditBox:Hide()
                spellReminderEditBox:Show()
                hideOnUseCheckButton:Show()
    
                hideOnUseCheckButton:SetPoint("LEFT", spellReminderEditBoxIcon, "RIGHT", spacing, 0)
                reminderColorPicker:SetPoint("LEFT", hideOnUseCheckButton.title, "RIGHT", spacing, 0)
            elseif reminderType == "SPELL" then
                if spellID == "NODATA" then
                    -- If the user selected "no data", just fall back to spell ID
                    reminderTypeDropdown:SetValue({3})
    
                    return
                end
    
                reminderData.display.type = "SPELL"
                reminderData.display.spellID = spellID
    
                spellReminderEditBox:SetText(spellID)
    
                textReminderEditBox:Hide()
                spellReminderEditBox:Hide()
                hideOnUseCheckButton:Show()
    
                hideOnUseCheckButton:SetPoint("LEFT", reminderTypeDropdown, "RIGHT", spacing, 0)
                reminderColorPicker:SetPoint("LEFT", hideOnUseCheckButton.title, "RIGHT", spacing, 0)
            end
        end
    )
    
    reminderTypeDropdown:SetPoint("TOPLEFT", relativeToDropdown, "BOTTOMLEFT", 0, -30)
    UIDropDownMenu_SetWidth(reminderTypeDropdown, 120)
    
    -- Text reminder edit box
    textReminderEditBox:SetSize(212, editBoxHeight)
    textReminderEditBox:SetPoint("LEFT", reminderTypeDropdown, "RIGHT", spacing, 0)

    LRP:AddTooltip(textReminderEditBox, "The text that is displayed when this reminder shows up during an encounter.")
    
    -- Spell reminder edit box
    spellReminderEditBox:SetPoint("LEFT", reminderTypeDropdown, "RIGHT", spacing, 0)
    spellReminderEditBox:SetSize(90, editBoxHeight)

    LRP:AddTooltip(
        spellReminderEditBox,
        "ID of the spell that this reminder should show.|n|nYou may enter a spell name here, and it will be converted to spell ID. |cff29ff62This only works if the spell is known by your class|r."
    )
    
    -- Spell reminder edit box icon
    spellReminderEditBoxIcon:SetParent(spellReminderEditBox)
    spellReminderEditBoxIcon:SetSize(iconSize, iconSize)
    spellReminderEditBoxIcon:SetPoint("LEFT", spellReminderEditBox, "RIGHT", spacing, 0)
    
    -- Spell reminder hide-on-use check button
    hideOnUseCheckButton:SetPoint("LEFT", spellReminderEditBoxIcon, "RIGHT", spacing, 0)
    hideOnUseCheckButton:SetChecked(true)
    LRP:AddTooltip(hideOnUseCheckButton, "Whether the reminder should disappear from your screen when you use the selected spell.")
    
    -- TTS check button/time slider
    ttsTimeSlider = LRP:CreateSlider(
        LRP.reminderConfig,
        "At remaining",
        0,
        20,
        function(ttsTime)
            reminderData.tts.time = ttsTime
        end
    )
    
    ttsCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "TTS",
        function(newValue)
            reminderData.tts.enabled = newValue
    
            ttsTimeSlider:SetShown(reminderData.tts.enabled)
        end
    )
    
    ttsCheckButton:SetPoint("TOPLEFT", reminderTypeDropdown, "BOTTOMLEFT", 0, -30)
    LRP:AddTooltip(ttsCheckButton, "Whether text-to-speech should play for this reminder.")
    
    ttsTimeSlider:SetPoint("LEFT", ttsCheckButton, "RIGHT", 50, 1)
    ttsTimeSlider:SetValue(5)
    ttsTimeSlider:SetShown(reminderData.tts)
    LRP:AddTooltip(ttsTimeSlider, "At what time (in seconds) remaining on the reminder the text-to-speech should play.")
    
    -- Glow check button/edit box
    glowNamesEditBox = LRP:CreateEditBox(
        LRP.reminderConfig,
        "Name(s)",
        function(glowNames)
            if reminderData.glow then
                reminderData.glow.names = {}
    
                for name in string.gmatch(glowNames, "([^,]+)") do
                    name = strtrim(name):lower():gsub("^%l", string.upper) -- Remove space and make sure only the first letter is capitalised

                    table.insert(reminderData.glow.names, name)
                end
            end

            if glowNames == "" then
                glowNamesEditBox:ShowHighlight(1, 0, 0)

                glowNamesEditBox.secondaryTooltipText = "|cffff0000(Nick)name(s) must be provided for glow(s) to show.|r"
                LRP:RefreshTooltip()
            else
                glowNamesEditBox:HideHighlight()

                glowNamesEditBox.secondaryTooltipText = nil
                LRP:RefreshTooltip()
            end
        end
    )
    
    glowCheckButton = LRP:CreateCheckButton(
        LRP.reminderConfig,
        "Glow",
        function(glow)
            reminderData.glow.enabled = glow
    
            glowNamesEditBox:SetShown(glow)
            glowPreviewFrame:SetShown(glow)

            UpdatePreviewGlow()
        end
    )
    
    glowCheckButton:SetPoint("TOPLEFT", ttsCheckButton, "BOTTOMLEFT", 0, -40)
    LRP:AddTooltip(glowCheckButton, "Whether this reminder should glow unit frames while showing.")
    
    glowNamesEditBox:SetSize(162, editBoxHeight)
    glowNamesEditBox:SetPoint("LEFT", glowCheckButton, "RIGHT", 50, 0)
    glowNamesEditBox:SetShown(reminderData.glow.enabled)
    LRP:AddTooltip(
        glowNamesEditBox,
        "Player(s) whose unit frames should glow while the reminder is showing. |cff29ff62Comma separated.|r" ..
        "|n|nCan be either names or nicknames."
    )

    -- Glow type dropdown
    glowTypeDropdown = LRP:CreateDropdown(
        glowNamesEditBox,
        "Glow type",
        {
            [1] = {text = "Pixel glow", value = "PIXEL"},
            [2] = {text = "Auto cast glow", value = "AUTOCAST"},
            [3] = {text = "Button glow", value = "BUTTON"},
            [4] = {text = "Proc glow", value = "PROC"}
        },
        function(glowType)
            reminderData.glow.type = glowType

            UpdatePreviewGlow()
        end
    )

    glowTypeDropdown:SetPoint("LEFT", glowNamesEditBox, "RIGHT", spacing, 0)
    UIDropDownMenu_SetWidth(glowTypeDropdown, 100)

    -- Glow color picker
    glowColorPicker = LRP:CreateColorPicker(
        glowTypeDropdown,
        "Color",
        function(r, g, b)
            reminderData.glow.color = {
                r = r,
                g = g,
                b = b
            }

            UpdatePreviewGlow()
        end,
        false
    )

    glowColorPicker:SetSize(20, 20)
    glowColorPicker:SetPoint("LEFT", glowTypeDropdown, "RIGHT", spacing, 0)

    LRP:AddTooltip(glowColorPicker, "Color that the glow will show up in.")

    -- Accept button
    acceptButton = CreateFrame("Button", nil, LRP.reminderConfig)

    acceptButton:SetSize(buttonSize, buttonSize)
    acceptButton:SetPoint("BOTTOMRIGHT", LRP.reminderConfig, "BOTTOM", -4, 10)
    acceptButton:SetHighlightAtlas("common-icon-checkmark", "ADD")

    acceptButton.tex = acceptButton:CreateTexture()
    acceptButton.tex:SetAllPoints(acceptButton)
    acceptButton.tex:SetAtlas("common-icon-checkmark")

    acceptButton:SetScript(
        "OnClick",
        function()
            CreateReminder()
            LRP.reminderConfig:Hide()
        end
    )

    LRP:AddTooltip(acceptButton, "Update this reminder")

    -- Delete button
    deleteButton = CreateFrame("Button", nil, LRP.reminderConfig)

    deleteButton:SetSize(buttonSize, buttonSize)
    deleteButton:SetPoint("BOTTOMLEFT", LRP.reminderConfig, "BOTTOM", 4, 10)
    deleteButton:SetHighlightAtlas("common-icon-redx", "ADD")

    deleteButton.tex = deleteButton:CreateTexture()
    deleteButton.tex:SetAllPoints(deleteButton)
    deleteButton.tex:SetAtlas("common-icon-redx")

    deleteButton:SetScript(
        "OnClick",
        function()
            LRP:ShowConfirmWindow(
                LRP.reminderConfig,
                "Are you sure you want to |cffff0000delete|r this reminder?",
                function()
                    LiquidRemindersSaved.reminders[timelineData.id][reminderID] = nil
        
                    LRP:BuildReminderLines()
                    LRP.reminderConfig:Hide()
                end
            )
        end
    )

    LRP:AddTooltip(deleteButton, "Delete this reminder")

    -- Make default button
    makeDefaultButton = LRP:CreateButton(
        LRP.reminderConfig,
        "Make default",
        function()
            LRP:ShowConfirmWindow(
                LRP.reminderConfig,
                "Are you sure you want to set the current config as the default?",
                function()
                    LiquidRemindersSaved.settings.defaultReminder = CopyTable(reminderData)

                    LRP:BuildReminderLines() -- Tooltips for MRT reminders might change, so rebuild them
                end
            )
        end
    )

    makeDefaultButton:SetPoint("BOTTOMLEFT", LRP.reminderConfig, "BOTTOMLEFT", 10, 10)

    LRP:AddTooltip(makeDefaultButton, "Sets the current config as the default. All newly made reminders will start out identical to it.|n|nThese settings are also applied to MRT reminders.")

    -- Test button
    testButton = LRP:CreateButton(
        LRP.reminderConfig,
        "Test",
        function()
            LRP.anchors.TEXT:HideReminder(reminderID, true)
            LRP.anchors.SPELL:HideReminder(reminderID, true)

            LRP.anchors[reminderData.display.type]:ShowReminder(reminderID, reminderData, 0)
        end
    )

    testButton:SetPoint("LEFT", makeDefaultButton, "RIGHT", 4, 0)

    -- Glow preview frame
    glowPreviewFrame = CreateFrame("Frame", nil, LRP.reminderConfig)

    glowPreviewFrame:SetSize(100, 55)
    glowPreviewFrame:SetPoint("BOTTOMRIGHT", LRP.reminderConfig, "BOTTOMRIGHT", -12, 12)

    glowPreviewFrame.tex = glowPreviewFrame:CreateTexture(nil, "BACKGROUND")
    glowPreviewFrame.tex:SetAllPoints(glowPreviewFrame)
    glowPreviewFrame.tex:SetColorTexture(0.25, 0.25, 0.25)

    glowPreviewFrame.text = glowPreviewFrame:CreateFontString(nil, "OVERLAY")
    glowPreviewFrame.text:SetFont(LRP.gs.visual.font, 13, LRP.gs.visual.fontFlags)
    glowPreviewFrame.text:SetPoint("CENTER", glowPreviewFrame, "CENTER")
    glowPreviewFrame.text:SetText("Glow|npreview")

    LRP:AddBorder(glowPreviewFrame)
end

local spellDataFrame = CreateFrame("Frame")

spellDataFrame:RegisterEvent("LOADING_SCREEN_DISABLED")
spellDataFrame:RegisterEvent("LEARNED_SPELL_IN_SKILL_LINE")

spellDataFrame:SetScript(
    "OnEvent",
    function(_, event, ...)
        -- GetSpellBookItemInfo does not return proper spec IDs immediately on login, so we collect data on LOADING_SCREEN_DISABLED
        if event == "LOADING_SCREEN_DISABLED" then
            QueueSpellBookUpdate(true)
        elseif event == "LEARNED_SPELL_IN_SKILL_LINE" then
            QueueSpellBookUpdate()
        end
    end
)